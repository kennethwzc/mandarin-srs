# Cursor AI Rules for Mandarin SRS Project (Pinyin Input Version)

## Project Overview
This is a Mandarin learning app where users:
1. See a Chinese character
2. Type the pinyin with correct tone marks
3. Get immediate feedback
4. Progress through spaced repetition

NO AUDIO - This is a typing-focused learning app.

## TypeScript Rules
- Always use TypeScript, never JavaScript
- Use strict mode (configured in tsconfig.json)
- No 'any' types unless absolutely necessary with justification
- Prefer interfaces over types for object shapes
- Use Zod for runtime validation
- Generate types from Drizzle schema using $inferSelect and $inferInsert

## Next.js App Router Rules
- Use Server Components by default
- Add 'use client' directive ONLY when needed:
  - useState, useEffect, other React hooks
  - Browser APIs (window, localStorage, etc.)
  - Event handlers (onClick, onChange, etc.)
- Prefer Server Actions over API routes for mutations
- Use dynamic imports for large client components
- Always add loading.tsx and error.tsx for routes
- Use route groups () for layout organization

## React Best Practices
- Functional components only, no class components
- Prefer const over let, never use var
- Use async/await over .then() chains
- Keep functions under 50 lines (extract to helpers)
- Extract reusable logic to custom hooks
- Use early returns to reduce nesting
- Memoize expensive components with React.memo()
- Add displayName to forwardRef components

## Database & Drizzle Rules
- Use Drizzle ORM, not raw SQL
- Always use transactions for multi-table operations
- Use prepared statements for repeated queries
- Add database indexes for frequently queried columns
- Never expose SUPABASE_SERVICE_ROLE_KEY to client
- Use Row Level Security (RLS) policies
- Validate all inputs with Zod before database operations

## Pinyin Input Specific Rules
- Always validate pinyin format (letters + optional tone marks)
- Support both numeric tones (ni3) and tone marks (nǐ)
- Validate tone marks: ā, á, ǎ, à, a (and for all vowels)
- Provide real-time feedback on pinyin correctness
- Handle edge cases: neutral tone, ü character
- Make tone selector keyboard-accessible (1-5 keys)
- Support both mouse and keyboard input methods

## Naming Conventions
- Files: kebab-case (pinyin-input.tsx, tone-selector.tsx)
- Components: PascalCase (PinyinInput, ToneSelector)
- Functions: camelCase (validatePinyin, addToneMark)
- Constants: UPPER_SNAKE_CASE (TONE_MARKS, VALID_FINALS)
- Types/Interfaces: PascalCase, optionally with prefix (IPinyin, ToneType)
- Boolean variables: is/has/should prefix (isCorrect, hasTone, shouldValidate)

## Import Organization
Always organize imports in this order:
1. React and Next.js imports
2. Third-party library imports
3. Internal @/ path imports
4. Relative imports
5. Type imports (import type)
6. CSS imports

## File Structure
- Group related files together in feature folders
- Place types near where they're used
- Keep components small and focused (single responsibility)
- Extract complex logic to lib/utils
- Co-locate tests with source files (__tests__/ folder)

## Error Handling
- Always use try-catch for async operations
- Return user-friendly error messages
- Log errors server-side with context
- Never expose sensitive info in client errors
- Use error boundaries for React component errors
- Validate inputs before processing

## Performance
- Use React.memo() for expensive components
- Implement virtualization for lists >100 items
- Optimize images with next/image
- Lazy load routes with dynamic imports
- Use server components for data fetching
- Cache expensive operations with React Query
- Debounce pinyin input validation (300ms)

## Security
- Never log sensitive data (passwords, tokens, PII)
- Validate all user input with Zod
- Use parameterized queries (Drizzle does this)
- Implement rate limiting on API routes
- Use HTTPS only in production
- Set secure headers (configured in next.config.js)
- Sanitize pinyin input to prevent XSS

## Testing
- Write tests for:
  - Utility functions (100% coverage)
  - Pinyin validation logic (critical)
  - SRS algorithm (critical path)
  - API routes (happy path + errors)
  - Complex components
- Use React Testing Library for component tests
- Mock external dependencies (Supabase, etc.)
- Keep tests fast (<1s per test)

## Comments & Documentation
- Add JSDoc for all public functions
- Explain WHY, not WHAT (code should be self-explanatory)
- Add comments for complex algorithms
- Keep comments up to date with code changes
- Use TODO comments with issue numbers
- Document security decisions
- Document pinyin edge cases (ü, neutral tone, etc.)

## Code Style
- Max line length: 100 characters
- Use Prettier for formatting (automatic)
- Use ESLint rules (no warnings)
- Add trailing commas for multi-line
- Use template literals over string concatenation
- Prefer optional chaining (?.) over nested ifs

## Git Commit Messages
Follow Conventional Commits:
- feat(scope): description
- fix(scope): description
- docs: description
- style: description
- refactor(scope): description
- test(scope): description
- chore: description

## Common Pitfalls to Avoid
❌ Using 'use client' unnecessarily
❌ Not handling loading and error states
❌ Forgetting to add indexes to database
❌ Exposing service role key to client
❌ Using any type without justification
❌ Not validating user input
❌ Ignoring TypeScript errors
❌ Large components (>200 lines)
❌ Deeply nested code (>3 levels)
❌ console.log in production code
❌ Not validating pinyin before submission
❌ Forgetting to handle ü character in pinyin

## When in Doubt
1. Check existing code patterns
2. Prefer TypeScript types over runtime checks
3. Optimize for readability over cleverness
4. Write self-documenting code
5. Add tests for complex logic

